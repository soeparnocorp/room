<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>READTalk - Private Edge Chat</title>
  <meta name="theme-color" content="#ff0000">
  <!-- Add adapter.js for WebRTC cross-browser compatibility -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/webrtc-adapter/8.1.2/adapter.min.js"></script>
<style type="text/css">
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  /* READTalk Primary - MURNI #ff0000 */
  --readtalk: #ff0000;
  --readtalk-dark: #cc0000;
  --readtalk-light: #ff3333;
  --readtalk-bg: #fff0f0;
  
  /* Base colors */
  --bg-primary: #ffffff;
  --bg-secondary: #f5f5f5;
  --text-primary: #333333;
  --text-secondary: #666666;
  --border-color: #e0e0e0;
  --roster-bg: #f8f9fa;
  --online-color: #4caf50;
  --offline-color: #9e9e9e;
  --header-bg: #ff0000;
  --hover-color: #fff0f0;
  --call-active: #4caf50;
  --call-incoming: #ff9800;
}

body.dark-mode {
  --bg-primary: #1a1a1a;
  --bg-secondary: #2d2d2d;
  --text-primary: #ffffff;
  --text-secondary: #b0b0b0;
  --border-color: #404040;
  --roster-bg: #252525;
  --header-bg: #cc0000;
  --hover-color: #332222;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  height: 100vh;
  overflow: hidden;
  transition: background-color 0.3s, color 0.3s;
}

/* HEADER - READTalk Red */
#app-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 48px;
  background-color: var(--header-bg);
  border-bottom: 1px solid rgba(255,255,255,0.2);
  display: flex;
  align-items: center;
  padding: 0 16px;
  z-index: 100;
  transition: background-color 0.3s;
}

#header-title {
  flex: 1;
  font-weight: 600;
  font-size: 18px;
  color: white;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#header-menu {
  position: relative;
}

#menu-button {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  padding: 8px;
  color: white;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#menu-button:hover {
  background-color: #cc0000;
}

#menu-dropdown {
  position: absolute;
  top: 48px;
  right: 0;
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  display: none;
  min-width: 200px;
  z-index: 1000;
}

#menu-dropdown.show {
  display: block;
}

.menu-item {
  padding: 12px 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 12px;
  color: var(--text-primary);
}

.menu-item:hover {
  background-color: var(--hover-color);
}

.menu-item:first-child {
  border-radius: 8px 8px 0 0;
}

.menu-item:last-child {
  border-radius: 0 0 8px 8px;
}

/* BACK BUTTON (SMARTPHONE ONLY) */
#back-button {
  display: none;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  margin-right: 12px;
  color: white;
  padding: 4px 8px;
}

#back-button:hover {
  background-color: #cc0000;
  border-radius: 4px;
}

/* MAIN CONTAINER */
#main-container {
  position: fixed;
  top: 48px;
  bottom: 48px;
  left: 0;
  right: 0;
  display: flex;
}

/* ROSTER - KIRI (30%) */
#roster {
  width: 30%;
  background-color: var(--roster-bg);
  border-right: 1px solid var(--border-color);
  overflow-y: auto;
  padding: 12px;
  transition: background-color 0.3s;
}

.roster-header {
  font-size: 12px;
  text-transform: uppercase;
  color: var(--text-secondary);
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border-color);
}

.roster-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  margin-bottom: 4px;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.roster-item:hover {
  background-color: var(--hover-color);
}

.status-indicator {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  margin-right: 12px;
}

.status-online {
  background-color: var(--online-color);
  box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
}

.status-offline {
  background-color: var(--offline-color);
}

.roster-name {
  flex: 1;
  font-weight: 500;
  font-size: 14px;
}

/* CHATLOG - KANAN (70%) */
#chatlog {
  width: 70%;
  overflow-y: auto;
  padding: 16px;
  background-color: var(--bg-primary);
  transition: background-color 0.3s;
}

/* ===== CALL HEADER ===== */
#chatlog-header {
  position: sticky;
  top: 0;
  background-color: var(--bg-primary);
  border-bottom: 1px solid var(--border-color);
  padding: 12px 16px;
  margin-bottom: 12px;
  z-index: 10;
  display: none;
  transition: background-color 0.3s;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

#chatlog-header.active {
  display: block;
}

.call-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.call-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.call-status {
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 12px;
  background-color: var(--online-color);
  color: white;
  font-weight: 500;
}

.call-status.incoming {
  background-color: var(--call-incoming);
}

.call-status.active {
  background-color: var(--call-active);
}

.call-participant {
  font-weight: 600;
  color: var(--text-primary);
}

.call-actions {
  display: flex;
  gap: 8px;
}

.call-button {
  width: 36px;
  height: 36px;
  border: none;
  border-radius: 50%;
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  background-color: var(--bg-secondary);
  color: var(--text-primary);
}

.call-start {
  background-color: #4caf50;
  color: white;
}

.call-start:hover {
  background-color: #45a049;
  transform: scale(1.05);
}

.call-end {
  background-color: #f44336;
  color: white;
}

.call-end:hover {
  background-color: #d32f2f;
  transform: scale(1.05);
}

.call-accept {
  background-color: #4caf50;
  color: white;
}

.call-reject {
  background-color: #f44336;
  color: white;
}

/* Call notification in chat */
.call-notification {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--hover-color);
  border-left: 4px solid #4caf50;
  padding: 12px 16px;
  margin: 8px 0;
  border-radius: 8px;
  animation: slideIn 0.3s;
}

.call-notification.incoming {
  border-left-color: #ff9800;
}

.call-notification.active {
  border-left-color: #f44336;
}

.call-notification-message {
  font-size: 14px;
  color: var(--text-primary);
}

.call-notification-actions {
  display: flex;
  gap: 8px;
}

.call-notification-btn {
  padding: 6px 12px;
  border: none;
  border-radius: 16px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: opacity 0.2s;
}

.call-notification-btn.accept {
  background-color: #4caf50;
  color: white;
}

.call-notification-btn.reject {
  background-color: #f44336;
  color: white;
}

.call-notification-btn:hover {
  opacity: 0.9;
}

/* Call badge di roster */
.call-badge {
  margin-left: 8px;
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 12px;
  background-color: #4caf50;
  color: white;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.call-badge:hover {
  background-color: #45a049;
}

.call-badge.active {
  background-color: #f44336;
  animation: pulse 1s infinite;
}

.call-badge.incoming {
  background-color: #ff9800;
  animation: pulse 1s infinite;
}

/* Audio indicator */
.audio-indicator {
  display: inline-flex;
  align-items: center;
  gap: 2px;
  margin-left: 8px;
}

.audio-indicator span {
  width: 3px;
  height: 3px;
  background-color: #4caf50;
  border-radius: 50%;
  animation: audioPulse 1s infinite;
}

.audio-indicator span:nth-child(2) {
  animation-delay: 0.2s;
}

.audio-indicator span:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes audioPulse {
  0%, 100% { transform: scaleY(1); }
  50% { transform: scaleY(2); }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.chat-message {
  margin-bottom: 12px;
  animation: fadeIn 0.3s;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.chat-message .username {
  font-weight: 600;
  color: #ff0000;
  margin-right: 8px;
}

.chat-message .timestamp {
  font-size: 11px;
  color: var(--text-secondary);
  margin-left: 8px;
}

.chat-message .message-content {
  color: var(--text-primary);
  word-break: break-word;
  margin-top: 4px;
  padding-left: 8px;
  border-left: 2px solid #ff0000;
}

.system-message {
  color: var(--text-secondary);
  font-style: italic;
  font-size: 13px;
  text-align: center;
  margin: 16px 0;
  padding: 8px;
  background-color: var(--hover-color);
  border-radius: 8px;
}

/* CHAT INPUT AREA */
#chat-input-container {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 48px;
  background-color: var(--bg-primary);
  border-top: 1px solid var(--border-color);
  display: flex;
  align-items: center;
  padding: 0 16px;
  gap: 12px;
  transition: background-color 0.3s;
}

#chat-input {
  flex: 1;
  height: 36px;
  border: 1px solid var(--border-color);
  border-radius: 18px;
  padding: 0 16px;
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  font-size: 14px;
  outline: none;
  transition: border-color 0.3s;
}

#chat-input:focus {
  border-color: #ff0000;
}

#send-button {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: #ff0000;
  padding: 8px;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#send-button:hover {
  background-color: var(--hover-color);
  color: #cc0000;
}

/* STATUS BAR */
#connection-status {
  position: fixed;
  top: 48px;
  left: 0;
  right: 0;
  height: 3px;
  background-color: var(--online-color);
  transform: scaleX(0);
  transition: transform 0.3s;
  z-index: 1000;
}

#connection-status.reconnecting {
  background-color: #ff9800;
  transform: scaleX(1);
  animation: pulse 1s infinite;
}

#connection-status.offline {
  background-color: #f44336;
  transform: scaleX(1);
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

/* FORMS */
#room-form, #name-form {
  position: fixed;
  z-index: 200;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: var(--bg-primary);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.form-content {
  max-width: 400px;
  width: 100%;
  text-align: center;
}

.form-content h2 {
  margin-bottom: 24px;
  color: #ff0000;
}

.form-content input {
  width: 100%;
  height: 48px;
  border: 2px solid var(--border-color);
  border-radius: 24px;
  padding: 0 20px;
  font-size: 16px;
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  margin-bottom: 16px;
}

.form-content input:focus {
  border-color: #ff0000;
  outline: none;
}

.form-content button {
  height: 48px;
  border: none;
  border-radius: 24px;
  padding: 0 32px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: opacity 0.2s;
}

#go-public, #go-private, #join-chat {
  background-color: #ff0000;
  color: white;
}

.form-content button:hover {
  opacity: 0.9;
}

.or-divider {
  margin: 24px 0;
  color: var(--text-secondary);
  position: relative;
}

.or-divider::before,
.or-divider::after {
  content: "";
  position: absolute;
  top: 50%;
  width: 45%;
  height: 1px;
  background-color: var(--border-color);
}

.or-divider::before { left: 0; }
.or-divider::after { right: 0; }

/* MODAL */
#settings-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: var(--bg-primary);
  padding: 24px;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.2);
  z-index: 1000;
  min-width: 300px;
}

.modal-header {
  font-weight: 600;
  margin-bottom: 16px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border-color);
  color: #ff0000;
}

.modal-content p {
  margin: 12px 0;
  color: var(--text-secondary);
}

#close-settings {
  width: 100%;
  height: 40px;
  background-color: #ff0000;
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  margin-top: 16px;
}

#close-settings:hover {
  background-color: #cc0000;
}

/* ===== SMARTPHONE STYLES ===== */
@media (max-width: 600px) {
  #main-container {
    flex-direction: column;
  }
  
  #roster {
    width: 100%;
    height: 100%;
    display: block;
  }
  
  #chatlog {
    width: 100%;
    height: 100%;
    display: none;
  }
  
  #back-button {
    display: block;
  }
  
  #chat-input-container {
    display: none;
  }
  
  .roster-item {
    padding: 12px 16px;
  }
  
  body.chat-active #roster {
    display: none;
  }
  
  body.chat-active #chatlog {
    display: block;
  }
  
  body.chat-active #chat-input-container {
    display: flex;
  }
}

/* HIDE BACK BUTTON ON DESKTOP */
@media (min-width: 601px) {
  #back-button {
    display: none !important;
  }
}

/* SCROLLBAR */
::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
  background: #ff0000;
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: #cc0000;
}

/* LINK */
a {
  color: #ff0000;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
</style>
</head>
<body>
  <!-- CONNECTION STATUS BAR -->
  <div id="connection-status"></div>

  <!-- HEADER - READTalk Red -->
  <header id="app-header">
    <button id="back-button">‚Üê</button>
    <div id="header-title">READTalk</div>
    <div id="header-menu">
      <button id="menu-button">‚ãÆ</button>
      <div id="menu-dropdown">
        <div class="menu-item" id="theme-toggle">
          <span>üåì</span>
          <span>Day/Night Mode</span>
        </div>
        <div class="menu-item" id="show-settings">
          <span>‚öôÔ∏è</span>
          <span>Settings</span>
        </div>
      </div>
    </div>
  </header>

  <!-- MAIN CONTAINER -->
  <div id="main-container">
    <!-- ROSTER (LEFT - 30%) -->
    <div id="roster">
      <div class="roster-header">Participants ‚Ä¢ <span id="participant-count">0</span> online</div>
      <div id="roster-list"></div>
    </div>

    <!-- CHATLOG (RIGHT - 70%) -->
    <div id="chatlog">
      <!-- CALL HEADER - akan muncul saat call active/incoming -->
      <div id="chatlog-header">
        <div class="call-header">
          <div class="call-info">
            <span class="call-status" id="call-status-label">‚óè Online</span>
            <span class="call-participant" id="call-participant-name"></span>
          </div>
          <div class="call-actions">
            <button id="accept-call-btn" class="call-button call-accept" style="display: none;" title="Accept Call">‚úì</button>
            <button id="reject-call-btn" class="call-button call-reject" style="display: none;" title="Reject Call">‚úó</button>
            <button id="start-call-btn" class="call-button call-start" title="Start Voice Call">üìû</button>
            <button id="end-call-btn" class="call-button call-end" style="display: none;" title="End Call">üì¥</button>
          </div>
        </div>
      </div>
      
      <!-- Messages container -->
      <div id="messages"></div>
    </div>
  </div>

  <!-- CHAT INPUT -->
  <div id="chat-input-container">
    <input type="text" id="chat-input" placeholder="Type a message...">
    <button id="send-button">‚û§</button>
  </div>

  <!-- ROOM FORM -->
  <div id="room-form">
    <div class="form-content">
      <h2>Welcome to READTalk</h2>
      <input type="text" id="room-name" placeholder="Enter room name" maxlength="32">
      <button id="go-public">Join Public Room</button>
      <div class="or-divider">or</div>
      <button id="go-private">Create Private Room</button>
    </div>
  </div>

  <!-- NAME FORM -->
  <div id="name-form" style="display: none;">
    <div class="form-content">
      <h2>Choose your name</h2>
      <input type="text" id="name-input" placeholder="Your name" maxlength="32">
      <button id="join-chat">Join READTalk</button>
      <p style="margin-top: 20px; color: var(--text-secondary);">Private chat on the edge<br>with Cloudflare Durable Objects</p>
    </div>
  </div>

  <!-- SETTINGS MODAL -->
  <div id="settings-modal" style="display: none;">
    <div class="modal-header">Settings</div>
    <div class="modal-content">
      <p>Device ID: <span id="device-id"></span></p>
      <p>Connection: <span id="connection-state">Disconnected</span></p>
      <p>Room: <span id="current-room"></span></p>
    </div>
    <button id="close-settings">Close</button>
  </div>

  <script>
    // State Management
    let currentWebSocket = null;
    let username = null;
    let roomname = null;
    let deviceId = localStorage.getItem('device_id');
    let isAtBottom = true;
    let reconnectAttempts = 0;
    let isConnected = false;
    let isDarkMode = localStorage.getItem('dark_mode') === 'true';
    let participants = new Map(); // name -> online status
    let pendingParticipants = [];
    let isChatActive = false; // Untuk smartphone: false = roster view, true = chat view

    // ========== WEBRTC CALL STATE ==========
    let callState = {
      active: false,
      incoming: false,
      participant: null,
      peerConnection: null,
      localStream: null,
      sfuApp: null,
      sessionId: null,
      trackNames: [],
      iceServers: null
    };

    // DOM Elements
    const elements = {
      roomForm: document.getElementById('room-form'),
      nameForm: document.getElementById('name-form'),
      roomName: document.getElementById('room-name'),
      nameInput: document.getElementById('name-input'),
      goPublic: document.getElementById('go-public'),
      goPrivate: document.getElementById('go-private'),
      joinChat: document.getElementById('join-chat'),
      roster: document.getElementById('roster'),
      rosterList: document.getElementById('roster-list'),
      chatlog: document.getElementById('chatlog'),
      messages: document.getElementById('messages'),
      chatInput: document.getElementById('chat-input'),
      sendButton: document.getElementById('send-button'),
      backButton: document.getElementById('back-button'),
      headerTitle: document.getElementById('header-title'),
      menuButton: document.getElementById('menu-button'),
      menuDropdown: document.getElementById('menu-dropdown'),
      themeToggle: document.getElementById('theme-toggle'),
      showSettings: document.getElementById('show-settings'),
      settingsModal: document.getElementById('settings-modal'),
      closeSettings: document.getElementById('close-settings'),
      deviceIdSpan: document.getElementById('device-id'),
      connectionState: document.getElementById('connection-state'),
      currentRoom: document.getElementById('current-room'),
      connectionStatus: document.getElementById('connection-status'),
      participantCount: document.getElementById('participant-count'),
      mainContainer: document.getElementById('main-container'),
      
      // Call elements
      chatlogHeader: document.getElementById('chatlog-header'),
      callStatusLabel: document.getElementById('call-status-label'),
      callParticipantName: document.getElementById('call-participant-name'),
      startCallBtn: document.getElementById('start-call-btn'),
      endCallBtn: document.getElementById('end-call-btn'),
      acceptCallBtn: document.getElementById('accept-call-btn'),
      rejectCallBtn: document.getElementById('reject-call-btn')
    };

    // Initialize device ID
    if (!deviceId) {
      deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
      localStorage.setItem('device_id', deviceId);
    }

    // Hostname - PAKAI DARI VERSI 1 YANG TERBUKTI BENAR
    let hostname = window.location.host;
    if (!hostname) {
      hostname = "account.soeparnocorp.workers.dev"; // MASIH PAKAI ENDPOINT LAMA YANG BENER
    }

    // Apply dark mode
    if (isDarkMode) {
      document.body.classList.add('dark-mode');
    }

    // ========== THEME TOGGLE ==========
    elements.themeToggle.addEventListener('click', () => {
      isDarkMode = !isDarkMode;
      document.body.classList.toggle('dark-mode', isDarkMode);
      localStorage.setItem('dark_mode', isDarkMode);
      elements.menuDropdown.classList.remove('show');
    });

    // ========== MENU DROPDOWN ==========
    elements.menuButton.addEventListener('click', (e) => {
      e.stopPropagation();
      elements.menuDropdown.classList.toggle('show');
    });

    document.addEventListener('click', () => {
      elements.menuDropdown.classList.remove('show');
    });

    // ========== SETTINGS MODAL ==========
    elements.showSettings.addEventListener('click', () => {
      elements.deviceIdSpan.textContent = deviceId;
      elements.connectionState.textContent = isConnected ? 'Connected' : 'Disconnected';
      elements.currentRoom.textContent = roomname || 'None';
      elements.settingsModal.style.display = 'block';
      elements.menuDropdown.classList.remove('show');
    });

    elements.closeSettings.addEventListener('click', () => {
      elements.settingsModal.style.display = 'none';
    });

    // ========== BACK BUTTON (SMARTPHONE) ==========
    elements.backButton.addEventListener('click', () => {
      if (window.innerWidth <= 600) {
        // HANYA VISIBILITY yang berubah, WebSocket tetap hidup
        isChatActive = false;
        document.body.classList.remove('chat-active');
        elements.headerTitle.textContent = 'READTalk';
        
        // Hide call header if not in active call
        if (!callState.active && !callState.incoming) {
          elements.chatlogHeader.classList.remove('active');
        }
      }
    });

    // ========== ROSTER CLICK (SMARTPHONE) ==========
    function setupRosterClick() {
      const rosterItems = document.querySelectorAll('.roster-item');
      rosterItems.forEach(item => {
        item.addEventListener('click', (e) => {
          // Don't trigger if clicking on call badge
          if (e.target.classList.contains('call-badge')) {
            return;
          }
          
          if (window.innerWidth <= 600) {
            const name = item.querySelector('.roster-name').textContent;
            
            // HANYA VISIBILITY yang berubah, WebSocket tetap hidup
            isChatActive = true;
            document.body.classList.add('chat-active');
            elements.headerTitle.textContent = `Chat with ${name}`;
            
            // Show call header if in call with this participant
            if (callState.active && callState.participant === name) {
              elements.chatlogHeader.classList.add('active');
              updateCallUI();
            }
            
            // Focus ke input
            setTimeout(() => elements.chatInput.focus(), 300);
          }
        });
      });
    }

    // ========== UPDATE CONNECTION STATUS ==========
    function updateConnectionStatus(status) {
      elements.connectionStatus.className = '';
      if (status === 'connected') {
        elements.connectionStatus.classList.remove('reconnecting', 'offline');
        isConnected = true;
        reconnectAttempts = 0;
      } else if (status === 'reconnecting') {
        elements.connectionStatus.classList.add('reconnecting');
        isConnected = false;
      } else if (status === 'offline') {
        elements.connectionStatus.classList.add('offline');
        isConnected = false;
      }
    }

    // ========== UPDATE ROSTER ==========
    function updateRoster() {
      elements.rosterList.innerHTML = '';
      participants.forEach((online, name) => {
        const item = document.createElement('div');
        item.className = 'roster-item';
        
        let callBadge = '';
        if (online && name !== username) {
          if (callState.active && callState.participant === name) {
            callBadge = '<span class="call-badge active" onclick="window.endCall()">üî¥</span>';
          } else if (callState.incoming && callState.participant === name) {
            callBadge = '<span class="call-badge incoming" onclick="window.acceptCall()">üìû</span>';
          } else {
            callBadge = '<span class="call-badge" onclick="window.startCall(\'' + name + '\')">üìû</span>';
          }
        }
        
        item.innerHTML = `
          <div class="status-indicator ${online ? 'status-online' : 'status-offline'}"></div>
          <span class="roster-name">${name}</span>
          ${callBadge}
        `;
        elements.rosterList.appendChild(item);
      });
      
      elements.participantCount.textContent = Array.from(participants.values()).filter(v => v).length;
      
      // Re-attach click handlers for smartphone
      setupRosterClick();
    }

    // ========== ADD PARTICIPANT ==========
    function addParticipant(name, online = true) {
      participants.set(name, online);
      updateRoster();
    }

    // ========== REMOVE PARTICIPANT ==========
    function removeParticipant(name) {
      participants.delete(name);
      updateRoster();
      
      // End call if participant left
      if (callState.active && callState.participant === name) {
        addSystemMessage(`üìû ${name} left the chat, call ended`);
        endCall();
      }
      
      // Add system message
      addSystemMessage(`${name} left the chat`);
    }

    // ========== ADD CHAT MESSAGE ==========
    function addChatMessage(name, text) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'chat-message';
      
      const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      if (name) {
        messageDiv.innerHTML = `
          <span class="username">${name}</span>
          <span class="timestamp">${timestamp}</span>
          <div class="message-content">${text}</div>
        `;
      } else {
        messageDiv.className = 'system-message';
        messageDiv.textContent = text;
      }
      
      elements.messages.appendChild(messageDiv);
      
      // Scroll hanya jika chatlog visible dan di bottom
      if (isAtBottom && window.innerWidth > 600 || (window.innerWidth <= 600 && isChatActive)) {
        elements.chatlog.scrollTop = elements.chatlog.scrollHeight;
      }
    }

    // ========== ADD SYSTEM MESSAGE ==========
    function addSystemMessage(text) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'system-message';
      messageDiv.textContent = text;
      elements.messages.appendChild(messageDiv);
    }

    // ========== ADD CALL NOTIFICATION ==========
    function addCallNotification(type, fromUsername, offer = null) {
      const notificationDiv = document.createElement('div');
      notificationDiv.className = `call-notification ${type}`;
      
      if (type === 'incoming') {
        notificationDiv.innerHTML = `
          <span class="call-notification-message">üìû Incoming call from <strong>${fromUsername}</strong></span>
          <div class="call-notification-actions">
            <button class="call-notification-btn accept" onclick="window.acceptCall()">Accept</button>
            <button class="call-notification-btn reject" onclick="window.rejectCall()">Reject</button>
          </div>
        `;
      } else if (type === 'outgoing') {
        notificationDiv.innerHTML = `
          <span class="call-notification-message">üìû Calling <strong>${fromUsername}</strong>...</span>
          <div class="call-notification-actions">
            <button class="call-notification-btn reject" onclick="window.endCall()">Cancel</button>
          </div>
        `;
      } else if (type === 'active') {
        notificationDiv.innerHTML = `
          <span class="call-notification-message">üìû In call with <strong>${fromUsername}</strong></span>
          <div class="call-notification-actions">
            <button class="call-notification-btn reject" onclick="window.endCall()">End Call</button>
          </div>
        `;
      }
      
      elements.messages.appendChild(notificationDiv);
      
      if (isAtBottom) {
        elements.chatlog.scrollTop = elements.chatlog.scrollHeight;
      }
    }

    // ========== UPDATE CALL UI ==========
    function updateCallUI() {
      if (callState.active) {
        elements.callStatusLabel.textContent = '‚óè In Call';
        elements.callStatusLabel.className = 'call-status active';
        elements.callParticipantName.textContent = callState.participant;
        elements.startCallBtn.style.display = 'none';
        elements.endCallBtn.style.display = 'flex';
        elements.acceptCallBtn.style.display = 'none';
        elements.rejectCallBtn.style.display = 'none';
        elements.chatlogHeader.classList.add('active');
      } else if (callState.incoming) {
        elements.callStatusLabel.textContent = '‚óè Incoming Call';
        elements.callStatusLabel.className = 'call-status incoming';
        elements.callParticipantName.textContent = callState.participant;
        elements.startCallBtn.style.display = 'none';
        elements.endCallBtn.style.display = 'none';
        elements.acceptCallBtn.style.display = 'flex';
        elements.rejectCallBtn.style.display = 'flex';
        elements.chatlogHeader.classList.add('active');
      } else {
        elements.chatlogHeader.classList.remove('active');
      }
      
      // Update roster to reflect call state
      updateRoster();
    }

    // ========== WEBRTC SFU CLASS ==========
    class RealtimeSFU {
      constructor(basePath = '/api') {
        this.basePath = basePath;
        this.sessionId = null;
        this.iceServers = null;
      }
      
      async getICEServers(ttl = 86400) {
        try {
          const response = await fetch(`${this.basePath}/turn/credentials`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ttl })
          });
          
          if (!response.ok) {
            throw new Error('Failed to get TURN credentials');
          }
          
          const data = await response.json();
          this.iceServers = data.iceServers;
          return this.iceServers;
        } catch (err) {
          console.error('Error getting ICE servers:', err);
          // Fallback to STUN only
          return [{
            urls: ['stun:stun.cloudflare.com:3478']
          }];
        }
      }
      
      async createPeerConnection() {
        if (!this.iceServers) {
          await this.getICEServers();
        }
        
        return new RTCPeerConnection({
          iceServers: this.iceServers,
          iceTransportPolicy: 'all',
          bundlePolicy: 'max-bundle',
          rtcpMuxPolicy: 'require'
        });
      }
      
      async sfuRequest(path, body, method = 'POST') {
        const response = await fetch(`${this.basePath}/sfu${path}`, {
          method,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        return await response.json();
      }
      
      async newSession(offerSDP) {
        const result = await this.sfuRequest('/sessions/new', {
          sessionDescription: { type: 'offer', sdp: offerSDP }
        });
        this.sessionId = result.sessionId;
        return result;
      }
      
      async newTracks(trackObjects, offerSDP = null) {
        const body = { tracks: trackObjects };
        if (offerSDP) {
          body.sessionDescription = { type: 'offer', sdp: offerSDP };
        }
        return await this.sfuRequest(`/sessions/${this.sessionId}/tracks/new`, body);
      }
      
      async sendAnswerSDP(answer) {
        return await this.sfuRequest(`/sessions/${this.sessionId}/renegotiate`, {
          sessionDescription: { type: 'answer', sdp: answer }
        }, 'PUT');
      }
    }

    // ========== WEBRTC CALL FUNCTIONS ==========
    
    // Check if WebRTC is supported
    function isWebRTCSupported() {
      return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    }

    // Start a call
    async function startCall(targetUsername) {
      if (!isWebRTCSupported()) {
        addSystemMessage('‚ö†Ô∏è WebRTC is not supported in your browser');
        return;
      }
      
      if (callState.active || callState.incoming) {
        addSystemMessage('‚ö†Ô∏è You are already in a call');
        return;
      }
      
      if (!targetUsername || targetUsername === username) {
        addSystemMessage('‚ö†Ô∏è Cannot call yourself');
        return;
      }
      
      if (!participants.get(targetUsername)) {
        addSystemMessage(`‚ö†Ô∏è ${targetUsername} is offline`);
        return;
      }
      
      try {
        addSystemMessage(`üìû Calling ${targetUsername}...`);
        
        // Initialize SFU
        callState.sfuApp = new RealtimeSFU();
        callState.participant = targetUsername;
        
        // Get user media (audio only)
        callState.localStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
          video: false
        });
        
        // Create peer connection with TURN
        callState.peerConnection = await callState.sfuApp.createPeerConnection();
        
        // Add local tracks
        callState.localStream.getTracks().forEach(track => {
          callState.peerConnection.addTransceiver(track, { direction: 'sendonly' });
        });
        
        // Handle ICE candidates
        callState.peerConnection.onicecandidate = (event) => {
          if (event.candidate && currentWebSocket) {
            currentWebSocket.send(JSON.stringify({
              type: 'call-signal',
              signal: {
                type: 'ice-candidate',
                target: targetUsername,
                candidate: event.candidate
              }
            }));
          }
        };
        
        // Handle connection state
        callState.peerConnection.onconnectionstatechange = () => {
          if (callState.peerConnection.connectionState === 'connected') {
            addSystemMessage(`üìû Call connected with ${targetUsername}`);
            addCallNotification('active', targetUsername);
          } else if (callState.peerConnection.connectionState === 'disconnected' ||
                     callState.peerConnection.connectionState === 'failed' ||
                     callState.peerConnection.connectionState === 'closed') {
            if (callState.active) {
              addSystemMessage(`üìû Call ended with ${targetUsername}`);
              endCall();
            }
          }
        };
        
        // Create offer
        await callState.peerConnection.setLocalDescription(
          await callState.peerConnection.createOffer()
        );
        
        // Create session
        const sessionResult = await callState.sfuApp.newSession(
          callState.peerConnection.localDescription.sdp
        );
        
        await callState.peerConnection.setRemoteDescription(
          new RTCSessionDescription(sessionResult.sessionDescription)
        );
        
        // Wait for connection
        await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => reject('Connection timeout'), 10000);
          callState.peerConnection.addEventListener('iceconnectionstatechange', () => {
            if (callState.peerConnection.iceConnectionState === 'connected') {
              clearTimeout(timeout);
              resolve();
            }
          });
        });
        
        // Register tracks
        const trackObjects = callState.localStream.getTracks().map(track => ({
          location: 'local',
          mid: track.id,
          trackName: `user_${username}_audio_${Date.now()}`
        }));
        
        await callState.peerConnection.setLocalDescription(
          await callState.peerConnection.createOffer()
        );
        
        const tracksResult = await callState.sfuApp.newTracks(
          trackObjects,
          callState.peerConnection.localDescription.sdp
        );
        
        await callState.peerConnection.setRemoteDescription(
          new RTCSessionDescription(tracksResult.sessionDescription)
        );
        
        // Save track names for signaling
        callState.trackNames = trackObjects.map(t => t.trackName);
        
        // Send call offer via WebSocket
        if (currentWebSocket) {
          currentWebSocket.send(JSON.stringify({
            type: 'call-signal',
            signal: {
              type: 'offer',
              target: targetUsername,
              sessionId: callState.sfuApp.sessionId,
              trackNames: callState.trackNames
            }
          }));
        }
        
        // Update state
        callState.active = true;
        callState.incoming = false;
        
        // Show outgoing notification
        addCallNotification('outgoing', targetUsername);
        
        // Update UI
        updateCallUI();
        
      } catch (err) {
        console.error('Call error:', err);
        addSystemMessage(`‚ùå Call failed: ${err.message}`);
        endCall();
      }
    }

    // Accept incoming call
    async function acceptCall() {
      if (!callState.incoming || !callState.participant) return;
      
      try {
        addSystemMessage(`üìû Accepting call from ${callState.participant}...`);
        
        // Initialize SFU
        callState.sfuApp = new RealtimeSFU();
        callState.sfuApp.sessionId = callState.sessionId;
        
        // Get user media
        callState.localStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
          video: false
        });
        
        // Create peer connection with TURN
        callState.peerConnection = await callState.sfuApp.createPeerConnection();
        
        // Add local tracks
        callState.localStream.getTracks().forEach(track => {
          callState.peerConnection.addTransceiver(track, { direction: 'sendonly' });
        });
        
        // Handle ICE candidates
        callState.peerConnection.onicecandidate = (event) => {
          if (event.candidate && currentWebSocket) {
            currentWebSocket.send(JSON.stringify({
              type: 'call-signal',
              signal: {
                type: 'ice-candidate',
                target: callState.participant,
                candidate: event.candidate
              }
            }));
          }
        };
        
        // Handle connection state
        callState.peerConnection.onconnectionstatechange = () => {
          if (callState.peerConnection.connectionState === 'connected') {
            addSystemMessage(`üìû Call connected with ${callState.participant}`);
            addCallNotification('active', callState.participant);
          } else if (callState.peerConnection.connectionState === 'disconnected' ||
                     callState.peerConnection.connectionState === 'failed' ||
                     callState.peerConnection.connectionState === 'closed') {
            if (callState.active) {
              addSystemMessage(`üìû Call ended with ${callState.participant}`);
              endCall();
            }
          }
        };
        
        // Register tracks
        const trackObjects = callState.localStream.getTracks().map(track => ({
          location: 'local',
          mid: track.id,
          trackName: `user_${username}_audio_${Date.now()}`
        }));
        
        await callState.peerConnection.setLocalDescription(
          await callState.peerConnection.createOffer()
        );
        
        const tracksResult = await callState.sfuApp.newTracks(
          trackObjects,
          callState.peerConnection.localDescription.sdp
        );
        
        await callState.peerConnection.setRemoteDescription(
          new RTCSessionDescription(tracksResult.sessionDescription)
        );
        
        // Send answer via WebSocket
        if (currentWebSocket) {
          currentWebSocket.send(JSON.stringify({
            type: 'call-signal',
            signal: {
              type: 'answer',
              target: callState.participant,
              sessionId: callState.sfuApp.sessionId,
              trackNames: trackObjects.map(t => t.trackName)
            }
          }));
        }
        
        // Update state
        callState.active = true;
        callState.incoming = false;
        
        // Update UI
        updateCallUI();
        
      } catch (err) {
        console.error('Accept call error:', err);
        addSystemMessage(`‚ùå Failed to accept call: ${err.message}`);
        endCall();
      }
    }

    // Reject incoming call
    function rejectCall() {
      if (callState.incoming && callState.participant && currentWebSocket) {
        currentWebSocket.send(JSON.stringify({
          type: 'call-signal',
          signal: {
            type: 'reject',
            target: callState.participant
          }
        }));
        
        addSystemMessage(`üìû Rejected call from ${callState.participant}`);
      }
      
      endCall();
    }

    // End current call
    function endCall() {
      // Close peer connection
      if (callState.peerConnection) {
        callState.peerConnection.close();
        callState.peerConnection = null;
      }
      
      // Stop local stream
      if (callState.localStream) {
        callState.localStream.getTracks().forEach(track => track.stop());
        callState.localStream = null;
      }
      
      // Send end call signal if active
      if (callState.active && callState.participant && currentWebSocket) {
        currentWebSocket.send(JSON.stringify({
          type: 'call-signal',
          signal: {
            type: 'end-call',
            target: callState.participant
          }
        }));
      }
      
      // Reset state
      callState.active = false;
      callState.incoming = false;
      callState.participant = null;
      callState.sfuApp = null;
      callState.sessionId = null;
      callState.trackNames = [];
      
      // Update UI
      updateCallUI();
    }

    // Handle incoming call signals
    function handleCallSignal(data) {
      const signal = data.signal;
      
      switch (signal.type) {
        case 'offer':
          // Incoming call
          if (!callState.active && !callState.incoming) {
            callState.incoming = true;
            callState.participant = signal.from;
            callState.sessionId = signal.sessionId;
            callState.trackNames = signal.trackNames || [];
            
            addSystemMessage(`üìû Incoming call from ${signal.from}`);
            addCallNotification('incoming', signal.from);
            updateCallUI();
          } else {
            // Busy - send reject
            if (currentWebSocket) {
              currentWebSocket.send(JSON.stringify({
                type: 'call-signal',
                signal: {
                  type: 'reject',
                  target: signal.from,
                  reason: 'busy'
                }
              }));
            }
          }
          break;
          
        case 'answer':
          // Call answered
          if (callState.active && callState.participant === signal.from) {
            addSystemMessage(`üìû ${signal.from} answered the call`);
            addCallNotification('active', signal.from);
          }
          break;
          
        case 'ice-candidate':
          // Add ICE candidate
          if (callState.peerConnection && callState.participant === signal.from) {
            callState.peerConnection.addIceCandidate(
              new RTCIceCandidate(signal.candidate)
            ).catch(err => console.error('Error adding ICE candidate:', err));
          }
          break;
          
        case 'end-call':
          // Call ended by other party
          if (callState.active && callState.participant === signal.from) {
            addSystemMessage(`üìû ${signal.from} ended the call`);
            endCall();
          }
          break;
          
        case 'reject':
          // Call rejected
          if (callState.active && callState.participant === signal.from) {
            addSystemMessage(`üìû ${signal.from} rejected the call`);
            endCall();
          }
          break;
      }
    }

    // ========== WEBSOCKET CONNECTION ==========
    function connectWebSocket() {
      const protocol = document.location.protocol === 'http:' ? 'ws://' : 'wss://';
      const ws = new WebSocket(`${protocol}${hostname}/api/room/${roomname}/websocket`);
      
      updateConnectionStatus('reconnecting');
      
      ws.onopen = () => {
        console.log('WebSocket connected');
        currentWebSocket = ws;
        updateConnectionStatus('connected');
        
        // Send name if already set
        if (username) {
          ws.send(JSON.stringify({ name: username }));
        }
        
        // Add pending participants
        pendingParticipants.forEach(name => addParticipant(name));
        pendingParticipants = [];
      };
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        
        // Handle call signals
        if (data.type === 'call-signal') {
          data.signal.from = data.signal.from || data.from || data.signal.target;
          handleCallSignal(data);
          return;
        }
        
        if (data.error) {
          addSystemMessage(`Error: ${data.error}`);
        } else if (data.joined) {
          addParticipant(data.joined);
          addSystemMessage(`${data.joined} joined the chat`);
        } else if (data.quit) {
          removeParticipant(data.quit);
        } else if (data.ready) {
          addSystemMessage('Connected to chat server');
          if (roomname && roomname.length === 64) {
            addSystemMessage('This is a private room. Share the URL to invite others.');
          }
        } else if (data.name && data.message) {
          addChatMessage(data.name, data.message);
        }
      };
      
      ws.onclose = () => {
        console.log('WebSocket closed, reconnecting...');
        updateConnectionStatus('reconnecting');
        
        // Mark all participants as offline
        participants.forEach((_, name) => {
          participants.set(name, false);
        });
        updateRoster();
        
        // End call if connection lost
        if (callState.active || callState.incoming) {
          addSystemMessage('üìû Connection lost, call ended');
          endCall();
        }
        
        // Attempt to reconnect
        setTimeout(connectWebSocket, Math.min(1000 * Math.pow(2, reconnectAttempts), 30000));
        reconnectAttempts++;
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        updateConnectionStatus('offline');
      };
    }

    // ========== JOIN CHAT ==========
    function joinChat() {
      // Hide room form, show name form
      elements.roomForm.style.display = 'none';
      elements.nameForm.style.display = 'flex';
      
      // Clean room name
      roomname = roomname.replace(/[^a-zA-Z0-9_-]/g, '').replace(/_/g, '-').toLowerCase();
      document.location.hash = '#' + roomname;
      elements.headerTitle.textContent = `#${roomContent = `#${room;
      
      // Connect WebSocket -name}`;
      
      // Connect WebSocket - TETname}`;
      
      // Connect WebSocket - TETAP JALAN
      connectWeb TETAP JALAN
      connectWebSocket();
AP JALAN
      connectWebSocket();
    }

    // ========== START CHAT AFTER NAME ==========
   Socket();
    }

    // ========== START CHAT AFTER NAME =========    }

    // ========== START CHAT AFTER NAME ==========
    function startChat() {
      username = elements.nameInput.value.trim();
      if (!username) return;
      
      localStorage.setItem('username', username function startChat() {
      username = elements.nameInput.value.trim();
      if (!username) return;
      
      localStorage.setItem('=
    function startChat() {
      username = elements.nameInput.value.trim();
      if (!username) return;
      
      localStorage.setItem('username', username);
      
      // Send name to WebSocket - TETAP DIKIRIM
      if (currentWebSocket && currentusername', username);
      
      // Send name to WebSocket - TETAP DIKIRIM
      if (currentWebSocket && current);
      
      // Send name to WebSocket - TETAP DIKIRIM
      if (currentWebSocketWebSocket.readyState === WebSocket.OPEN) {
        currentWebSocket.send(JSON.stringify({ nameWebSocket.readyState === WebSocket.OPEN) {
        currentWebSocket.send(JSON.stringify({ name && currentWebSocket.readyState === WebSocket.OPEN) {
        currentWebSocket.send(JSON.stringify({ name: username }));
      }
      
      // Hide name form
      elements: username }));
      }
      
      // Hide name form
      elements: username }));
      }
      
      // Hide name form
      elements.nameForm.style.display = 'none';
      
      // Show main interface - HANYA.nameForm.style.display = 'none';
      
      // Show main interface - HANYA VISIB.nameForm.style.display = 'none';
      
      // Show main interface - HANYA VISIBILITY
      if (window.innerWidth <= 600) {
        // Di smartphone: roster tampil, chatlog & input VISIBILITY
      if (window.innerWidth <= 600) {
        // Di smartphone: roster tampil, chatlog & inputILITY
      if (window.innerWidth <= 600) {
        // Di smartphone: roster tampil, chatlog & input hidden
        isChatActive = false;
        document.body.classList.remove('chat-active');
      } else {
 hidden
        isChatActive = false;
        document.body.classList.remove('chat-active');
      } else {
        // hidden
        isChatActive = false;
        document.body.classList.remove('chat-active');
      } else {
        // Di desktop: semua        // Di desktop: semua tampil
        elements.roster.style.display = 'block Di desktop: semua tampil
        elements.roster.style.display = 'block';
        elements.chatlog.style.display = 'block';
      }
      
      tampil
        elements.roster.style.display = 'block';
        elements.chatlog.style.display = 'block';
      }
      
      if (';
        elements.chatlog.style.display = 'block';
      }
      
      if (window.innerWidth > 600 if (window.innerWidth > 600) {
        elements.chatInput.focus();
      }
    }

    // ========== EVENTwindow.innerWidth > 600) {
        elements.chatInput.focus();
      }
    }

    // =========) {
        elements.chatInput.focus();
      }
    }

    // ========== EVENT LISTENERS ==========
    
    // Room form
 LISTENERS ==========
    
    // Room form
    elements.goPublic.addEventListener('= EVENT LISTENERS ==========
    
    // Room form
    elements.goPublic.addEventListener('click', () => {
      roomname = elements.roomName.value.trim();
      if (roomname) {
        joinChat();
         elements.goPublic.addEventListener('click', () => {
      roomname = elements.roomName.valueclick', () => {
      roomname = elements.roomName.value.trim();
      if (roomname) {
        joinChat();
      }
    }
    });
    
    elements.goPrivate.addEventListener('click', async () => {
      try {
        elements.goPublic.disabled = true;
        elements.trim();
      if (roomname) {
        joinChat();
      }
    });
    
    elements.goPrivate.addEventListener('click', async () => {
      try {
        elements.goPublic.disabled = true;
        elements });
    
    elements.goPrivate.addEventListener('click', async () => {
      try {
        elements.goPublic.disabled = true;
        elements.goPrivate.disabled = true;
        
        const response = await fetch(`https://${hostname.goPrivate.disabled = true;
        
        const response = await fetch(`https://${hostname}/api.goPrivate.disabled = true;
        
        const response = await fetch(`https://${hostname}/api/room`, { method: 'POST' });
        if (!response.ok) throw new Error('Failed to}/api/room`, { method: 'POST' });
        if (!response.ok) throw new Error('/room`, { method: 'POST' });
        if (!response.ok) throw new Error('Failed to create room');
        
        roomname = await response.text();
        joinChat();
 create room');
        
        roomname = await response.text();
        joinChat();
Failed to create room');
        
        roomname = await response.text();
        joinChat();
      } catch (err) {
        alert('Failed to create private room');
        console.error(err);
      } finally {
             } catch (err) {
        alert('Failed to create private room');
        console.error(err);
      } finally {
        elements.goPublic.disabled = false;
        elements.goPrivate.disabled      } catch (err) {
        alert('Failed to create private room');
        console.error(err);
      } finally {
        elements.goPublic.disabled = false;
        elements.goPrivate.disabled = false elements.goPublic.disabled = false;
        elements.goPrivate.disabled = false;
      }
    });
    
    elements.roomName.addEventListener('keypress', (e) => = false;
      }
    });
    
    elements.roomName.addEventListener('keypress', (e) => {
     ;
      }
    });
    
    elements.roomName.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        elements.goPublic.click {
      if (e.key === 'Enter') {
        e.preventDefault();
        elements.goPublic.click if (e.key === 'Enter') {
        e.preventDefault();
        elements.goPublic.click();
      }
    });
    
    // Name form
    elements.joinChat.addEventListener('click', startChat);
();
      }
    });
    
    // Name form
    elements.joinChat.addEventListener('click', startChat);
();
      }
    });
    
    // Name form
    elements.joinChat.addEventListener('click', startChat);
    
    elements.nameInput.addEventListener('keypress',    
    elements.nameInput.addEventListener('keypress',    
    elements.nameInput.addEventListener('keypress', (e) => (e) => {
      if (e.key === 'Enter') (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        startChat();
      }
    });
    
 {
      if (e.key === 'Enter') {
        e.preventDefault();
        startChat();
      }
    });
    
 {
        e.preventDefault();
        startChat();
      }
    });
    
    // Chat input
    elements.sendButton.addEventListener('click', () => {
      const message = elements.chatInput    // Chat input
    elements.sendButton.addEventListener('click', () => {
      const message = elements.ch    // Chat input
    elements.sendButton.addEventListener('click', () => {
      const message = elements.chatInput.value.trim();
      if (message && currentWebSocket && currentWebSocket.readyState === WebSocket.OPEN) {
        currentWeb.value.trim();
      if (message && currentWebSocket && currentWebSocket.readyState === WebSocket.OPEN) {
        currentWebatInput.value.trim();
      if (message && currentWebSocket && currentWebSocket.readyState === WebSocket.OPEN) {
        currentWebSocket.send(JSON.stringify({ message }));
        elements.chatInput.value = '';
      }
    });
    
    elements.chatInput.addEventListener('keypressSocket.send(JSON.stringify({ message }));
        elements.chatInput.value = '';
      }
    });
    
    elements.chatInput.addEventListener('Socket.send(JSON.stringify({ message }));
        elements.chatInput.value = '';
      }
    });
    
    elements.chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter', (e) => {
      if (e.key === 'Enter' &&keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        elements.sendButton.click();
      }
   ' && !e.shiftKey) {
        e.preventDefault();
        elements.sendButton.click();
      }
    });
    
 !e.shiftKey) {
        e.preventDefault();
        elements.sendButton.click();
      }
    });
    
    elements.chatInput.addEventListener('input', (e) => {
      if (e.target.value });
    
    elements.chatInput.addEventListener('input', (e) => {
      if (e.target.value    elements.chatInput.addEventListener('input', (e) => {
      if (e.target.value.length > 256) {
        e.target.value = e.target.value.slice(0,.length > 256) {
        e.target.value = e.target.value.slice(.length > 256) {
        e.target.value = e.target.value.slice(0, 256);
      }
    });
    
    // Call button events
    elements.startCallBtn.addEventListener('click 256);
      }
    });
    
    // Call button events
0, 256);
      }
    });
    
    // Call button events
    elements.startCallBtn.addEventListener('click', () => {
      if (window.innerWidth <= 600 && isChatActive) {
        const current', () => {
      if (window.innerWidth <= 600 && isChatActive) {
        const current    elements.startCallBtn.addEventListener('click', () => {
      if (window.innerWidth <= 600 && isChatActive) {
        const currentChatName = elements.headerTitle.textContent.replace('Chat with ', '');
        startCall(currentChatName);
ChatName = elements.headerTitle.textContent.replace('Chat with ', '');
        startCall(currentChatChatName = elements.headerTitle.textContent.replace('Chat with ', '');
        startCall(currentChat      }
    });
    
    elements.endCallBtn.addEventListener('click', endCall);
    elements.acceptCallName);
      }
    });
    
    elements.endCallBtn.addEventListener('click', endCall);
    elements.acceptCallBtn.addEventListener('click', acceptCall);
    elements.rejectCallBtn.addEventListener('Name);
      }
    });
    
    elements.endCallBtn.addEventListener('click', endCall);
    elements.acceptCallBtn.addEventListener('click', acceptCall);
    elements.rejectCallBtn.addEventListener('click', rejectCall);
    
Btn.addEventListener('click', acceptCall);
    elements.rejectCallBtn.addEventListener('click', rejectCall);
    
click', rejectCall);
    
    // Make functions global for onclick handlers
    window.startCall = startCall;
    window.acceptCall = acceptCall;
    window    // Make functions global for onclick handlers
    window.startCall = startCall;
    window.acceptCall = acceptCall;
    window.rejectCall = rejectCall;
    window.endCall = endCall;
    
    // Scroll detection
    elements.ch    // Make functions global for onclick handlers
    window.startCall = startCall;
    window.acceptCall = acceptCall;
    window.rejectCall = rejectCall;
    window.endCall = endCall;
    
    // Scroll detection
    elements.chatlog.addEventListener('scroll', () => {
      isAtBottom = elements.ch.rejectCall = rejectCall;
    window.endCall = endCall;
    
    // Scroll detection
    elements.chatlog.addEventListener('scroll', () => {
      isAtBottom = elements.chatlog.scrollTop +atlog.addEventListener('scroll', () => {
      isAtBottom = elements.chatlog.scrollTop + elements.chatlog.clientHeight >= elements.chatlog.scrollHeight;
    });
    
atlog.scrollTop + elements.chatlog.clientHeight >= elements.chatlog.scrollHeight;
    });
    
    // Keyboard handling for mobile elements.chatlog.clientHeight >= elements.chatlog.scrollHeight;
    });
    
    // Keyboard handling for mobile
    if ('visualViewport' in window) {
    // Keyboard handling for mobile
    if ('visualViewport' in window) {
      window
    if ('visualViewport' in window) {
      window.visualViewport.addEventListener('      window.visualViewport.addEventListener('resize', ().visualViewport.addEventListener('resize', () => {
        if (isAtBottom && (window.innerWidth > 600 || isChatActive)) {
          elementsresize', () => {
        if (isAtBottom && (window.innerWidth > 600 || isChatActive)) {
          elements => {
        if (isAtBottom && (window.innerWidth > 600 || isChatActive)) {
          elements.chatlog.scrollTop = elements.chatlog.scrollHeight;
        }
      });
    }
    
    //.chatlog.scrollTop = elements.chatlog.scrollHeight;
        }
      });
    }
    
    // Initialize from URL hash
.chatlog.scrollTop = elements.chatlog.scrollHeight;
        }
      });
    }
    
    // Initialize from URL hash
    if (window.location.hash.length > 1) {
      roomname = window.location.hash.slice(1);
      joinChat();
    }
 Initialize from URL hash
    if (window.location.hash.length > 1) {
      roomname = window.location.hash    if (window.location.hash.length > 1) {
      roomname = window.location.hash.slice(1);
      joinChat();
    }
    
       
    // Load room data - DARI VERSI 1.slice(1);
      joinChat();
    }
    
    // Load room data - DARI VERSI 1
    async function loadRoomData() {
      try {
        const // Load room data - DARI VERSI 1
    async function loadRoomData() {
      try {
        const response = await fetch(`https
    async function loadRoomData() {
      try {
        const response = await fetch(`https response = await fetch(`https://${hostname}/api/rooms`);
        const rooms = await://${hostname}/api/rooms`);
        const rooms = await response.json();
        console.log('Available rooms:', rooms);
      } catch (err) {
        console.error('Failed to load rooms:',://${hostname}/api/rooms`);
        const rooms = await response.json();
        console.log('Available rooms:', rooms);
      } catch (err) {
        console.error('Failed to load response.json();
        console.log('Available rooms:', rooms);
      } catch (err) {
        console.error('Failed to load rooms:', err);
      }
    }
    
    loadRoomData();
  </script>
</body>
</html>
